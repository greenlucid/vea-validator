# Pending Implementation: Proof Relay Execution

## What's Missing

The validator currently listens to `SnapshotSent` events but doesn't execute the queued L2â†’L1 messages on L1 after the 7-day delay.

**Location**: [main.rs:230-238](main.rs#L230-L238) - currently just a TODO

## What Needs to Happen

### Step 1: Track L2ToL1Transaction Events (Not SnapshotSent)

When `inbox.sendSnapshot()` is called, it triggers `ARB_SYS.sendTxToL1()` which emits TWO events:
1. `SnapshotSent(epoch, ticketID)` - from VeaInbox contract
2. `L2ToL1Transaction(...)` - from ArbSys precompile at `0x0000000000000000000000000000000000000064`

You need to listen to **BOTH** events from the same transaction and correlate them.

**Event signature**: `L2ToL1Transaction(address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes)`

**Event fields**:
- `caller` (address) - indexed
- `destination` (address) - indexed
- `hash` (uint256) - indexed
- `position` (uint256) - indexed (THIS IS YOUR `leaf` INDEX)
- `arbBlockNum` (uint256)
- `ethBlockNum` (uint256)
- `timestamp` (uint256)
- `callvalue` (uint256)
- `data` (bytes)

### Step 2: Store Complete Event Data

Update `SnapshotSentEvent` struct in [event_listener.rs:18-22](event_listener.rs#L18-L22):

```rust
pub struct SnapshotSentEvent {
    pub epoch: u64,
    pub ticket_id: FixedBytes<32>,
    pub timestamp: u64,
    // NEW - from L2ToL1Transaction event:
    pub position: U256,        // This is the leaf index
    pub caller: Address,
    pub destination: Address,
    pub arb_block_num: U256,
    pub eth_block_num: U256,
    pub l2_timestamp: U256,
    pub callvalue: U256,
    pub data: Vec<u8>,
}
```

### Step 3: Fetch L2ToL1Transaction Event Data

In [event_listener.rs:80-117](event_listener.rs#L80-L117), when you get `SnapshotSent`, immediately query the same transaction for the `L2ToL1Transaction` event:

```rust
// After getting SnapshotSent log
let tx_hash = log.transaction_hash.unwrap();
let receipt = self.provider.get_transaction_receipt(tx_hash).await?;

// Find L2ToL1Transaction event in the same receipt
let arb_sys_address = Address::from_str("0x0000000000000000000000000000000000000064").unwrap();
let l2_to_l1_sig = keccak256("L2ToL1Transaction(address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes)");

for log in receipt.unwrap().logs() {
    if log.address() == arb_sys_address && log.topics()[0] == l2_to_l1_sig {
        // Parse L2ToL1Transaction event
        let position = U256::from_be_bytes(log.topics()[3].0);
        let caller = Address::from_slice(&log.topics()[1].0[12..]);
        let destination = Address::from_slice(&log.topics()[2].0[12..]);
        // Decode data field for remaining parameters
        // (arbBlockNum, ethBlockNum, timestamp, callvalue, data)
        // Use alloy ABI decoding
    }
}
```

### Step 4: Update ProofRelay Storage

Update [proof_relay.rs:10](proof_relay.rs#L10) to store full event data:

```rust
pub struct ProofRelay {
    pending: Arc<RwLock<HashMap<u64, L2ToL1MessageData>>>,
}

struct L2ToL1MessageData {
    position: U256,
    caller: Address,
    destination: Address,
    arb_block_num: U256,
    eth_block_num: U256,
    timestamp: u64,
    l2_timestamp: U256,
    callvalue: U256,
    data: Vec<u8>,
}
```

### Step 5: Implement Relay Handler

Replace the TODO at [main.rs:230-238](main.rs#L230-L238) with actual execution:

```rust
let relay_handle = tokio::spawn(async move {
    proof_relay.watch_and_relay(move |epoch, msg_data| {
        let route = route_relay.clone();
        let arb_rpc = arbitrum_rpc.clone();
        let eth_provider = destination_provider.clone();
        let outbox_addr = outbox_address;
        Box::pin(async move {
            println!("[{}] Executing proof relay for epoch {}", route, epoch);

            // STEP A: Get size from Arbitrum
            let arb_sys = IArbSys::new(
                Address::from_str("0x0000000000000000000000000000000000000064").unwrap(),
                arb_provider
            );
            let (size, _root, _partials) = arb_sys.sendMerkleTreeState().call().await?;

            // STEP B: Construct proof via NodeInterface RPC call
            let node_interface = Address::from_str("0x00000000000000000000000000000000000000C8").unwrap();
            let proof_data = construct_outbox_proof_rpc(
                &arb_rpc,
                size,
                msg_data.position
            ).await?;

            // STEP C: Execute on L1 Outbox
            let outbox = IOutbox::new(outbox_addr, eth_provider);
            let tx = outbox.executeTransaction(
                proof_data.proof,
                msg_data.position,
                msg_data.caller,
                msg_data.destination,
                msg_data.arb_block_num,
                msg_data.eth_block_num,
                msg_data.l2_timestamp,
                msg_data.callvalue,
                Bytes::from(msg_data.data)
            );

            let receipt = tx.send().await?.get_receipt().await?;
            if !receipt.status() {
                return Err("executeTransaction failed".into());
            }

            println!("[{}] Proof relay executed successfully for epoch {}", route, epoch);
            Ok(())
        })
    }).await
});
```

### Step 6: Implement RPC Helper for constructOutboxProof

Create helper function (NodeInterface is RPC-only, not a contract):

```rust
async fn construct_outbox_proof_rpc(
    arb_rpc: &str,
    size: U256,
    leaf: U256,
) -> Result<ProofData, Box<dyn std::error::Error + Send + Sync>> {
    // Call NodeInterface via eth_call to 0xC8
    let node_interface = Address::from_str("0x00000000000000000000000000000000000000C8")?;

    // Encode constructOutboxProof(uint256,uint256) call
    let call_data = encode_function_call("constructOutboxProof", &[size, leaf]);

    // Make eth_call RPC request
    let result = provider.call(
        TransactionRequest::default()
            .to(node_interface)
            .input(call_data.into())
    ).await?;

    // Decode (bytes32 send, bytes32 root, bytes32[] proof)
    decode_proof_response(result)
}
```

### Step 7: Add Missing Contract Bindings

Generate bindings for:
- `IArbSys` (for `sendMerkleTreeState()`)
- `IOutbox` (for `executeTransaction()`)

Add to `contracts/` and regenerate with `forge bind`.

## Summary of Changes Required

1. **event_listener.rs**: Listen to BOTH `SnapshotSent` AND `L2ToL1Transaction`, correlate by tx hash
2. **event_listener.rs**: Update `SnapshotSentEvent` struct with 8 new fields
3. **proof_relay.rs**: Update storage to hold full message data
4. **main.rs**: Implement relay handler (replace TODO)
5. **main.rs**: Add `construct_outbox_proof_rpc()` helper function
6. **contracts/**: Add `IArbSys.sol` and `IOutbox.sol` bindings
7. **Cargo.toml**: May need `alloy-sol-macro` for ABI decoding if not already present

That's it. No options, no "maybe". Do these 7 things and proof relay is DONE.
