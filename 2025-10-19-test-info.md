# Test Infrastructure Documentation

## Test Files Location
- `tests/event_listener_test.rs` - Event listener tests
- `tests/validator_integration_test.rs` - Full validator integration tests

## CRITICAL: Test Fixtures (YOU WILL NEED THIS)

### What are Fixtures?
Fixtures are test utilities that manage blockchain state snapshots. They allow tests to:
1. **Take snapshots** of blockchain state before test runs
2. **Revert to snapshots** after test completes (cleanup)
3. **Keep tests isolated** - changes in one test don't affect others

### TestFixture Implementation Pattern

#### Single Chain Fixture (event_listener_test.rs:21-55)
```rust
struct TestFixture<P: Provider> {
    provider: Arc<P>,
    snapshot_id: Option<String>,
}

impl<P: Provider> TestFixture<P> {
    fn new(provider: Arc<P>) -> Self { ... }

    async fn take_snapshot(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let snapshot_result: serde_json::Value = self.provider
            .raw_request("evm_snapshot".into(), vec![])
            .await?;
        self.snapshot_id = Some(snapshot_result.as_str().unwrap().to_string());
        Ok(())
    }

    async fn revert_snapshot(&self) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(ref snapshot_id) = self.snapshot_id {
            self.provider.raw_request("evm_revert".into(), vec![serde_json::json!(snapshot_id)]).await?;
        }
        Ok(())
    }
}
```

#### Dual Chain Fixture (validator_integration_test.rs:17-65)
```rust
struct TestFixture<P1: Provider, P2: Provider> {
    eth_provider: Arc<P1>,
    arb_provider: Arc<P2>,
    eth_snapshot_id: Option<String>,
    arb_snapshot_id: Option<String>,
}

impl<P1: Provider, P2: Provider> TestFixture<P1, P2> {
    fn new(eth_provider: Arc<P1>, arb_provider: Arc<P2>) -> Self { ... }

    async fn take_snapshots(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // Takes snapshots on BOTH chains
        // Required because validator operates across two chains
    }

    async fn revert_snapshots(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Reverts BOTH chains to clean state
    }
}
```

**WHY YOU NEED FIXTURES**: Without them, tests pollute each other's state and become flaky/impossible to run multiple times.

## Test Utilities

### advance_time (validator_integration_test.rs:67-78)
```rust
async fn advance_time<P: Provider>(provider: &P, seconds: u64) {
    provider.raw_request("evm_increaseTime".into(), vec![serde_json::json!(seconds)]).await?;
    provider.raw_request("evm_mine".into(), vec![]).await?;
}
```
**Purpose**: Simulate time passing in local blockchain (for epoch transitions, claim periods, etc.)

### Test Private Key
```rust
const TEST_PRIVATE_KEY: &str = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
```
**This is Anvil's default test account** - DO NOT use in production

## Test Patterns

### Pattern 1: Event Watching Tests (event_listener_test.rs:77-139)
1. Create fixture and take snapshot
2. Start event listener in background with `tokio::spawn`
3. Use `tokio::sync::mpsc::channel` to receive events from handler
4. Trigger blockchain event manually
5. Wait for handler callback with `tokio::time::timeout`
6. Verify event was received
7. Abort background task
8. Revert snapshot

### Pattern 2: Reactive Validator Tests (validator_integration_test.rs:82-234)
Tests that validator REACTS to events (not manual function calls):
1. Setup epoch with messages and snapshot
2. Advance time to make epoch claimable
3. **Start validator components BEFORE attack**
4. Use `Arc<AtomicBool>` flags to detect validator reactions
5. Trigger malicious behavior (wrong claim)
6. Wait with `tokio::time::timeout` for validator to react
7. Verify validator challenged automatically
8. Cleanup with fixture revert

**CRITICAL**: Tests use `#[serial]` attribute to prevent parallel execution (blockchain state conflicts)

### Pattern 3: Startup Sync Tests (validator_integration_test.rs:599-744)
Tests that validator catches up on missed events:
1. Create malicious claim BEFORE validator starts (simulate downtime)
2. Start validator and call `startup_sync_and_verify()`
3. Verify validator detects and challenges old incorrect claim
4. Proves validator doesn't rely solely on live event watching

## Test Scenarios Covered

### ARB_TO_ETH Route
- **Wrong claim detection**: Validator detects and challenges incorrect claims
- **Bridge resolution**: Validator triggers `sendSnapshot` after challenge
- **Startup sync**: Validator catches attacks that occurred during downtime
- **Honest claiming**: Validator makes claim when epoch ends with no existing claim

### ARB_TO_GNOSIS Route
- **WETH-based deposits**: Tests WETH approval flow for Gnosis challenges
- **Cross-chain verification**: Verifies claims on Gnosis against Arbitrum snapshots

## Dependencies You Cannot Remove

### Required Test Crates
```toml
[dev-dependencies]
serial_test = "*"  # For #[serial] attribute - prevents parallel test execution
tokio = { features = ["sync", "time"] }  # For channels and timeouts
serde_json = "*"  # For RPC raw_request calls
```

### Required RPC Methods (for local testing)
- `evm_snapshot` - Create blockchain state snapshot
- `evm_revert` - Revert to previous snapshot
- `evm_increaseTime` - Fast-forward blockchain time
- `evm_mine` - Mine a block

**These only work on local test networks (Anvil/Hardhat), NOT mainnet**

## What Was Removed from claim_handler.rs

The inline test module at lines 267-315 was removed. It contained:
- A basic setup test that verified ClaimHandler could be created
- Checked environment variables were loadable
- Called `get_claim_for_epoch(0)` to verify basic RPC connectivity

**Why it was deleted**:
1. Redundant - same setup is in integration tests
2. Tests should be in `/tests` directory, not inline
3. Only tested construction, not actual validator behavior

**If you need to recreate tests**: Use the patterns in `/tests` directory, not inline modules.

## Config Integration

Tests use `ValidatorConfig::from_env()` from your actual code (validator_integration_test.rs:88, 244, 442, 610, 757).

Some tests also call **methods that don't exist yet** in ValidatorConfig:
- `c.setup_arb_to_eth()` (line 90, 247, 613, 758)
- `c.setup_arb_to_gnosis()` (line 445)

**These are MISSING from your current code** - tests expect these helper methods to exist.

## Environment Variables Required for Tests
```bash
ARBITRUM_RPC_URL=http://localhost:8545
ETHEREUM_RPC_URL=http://localhost:8546  # or MAINNET_RPC_URL
GNOSIS_RPC_URL=http://localhost:8547
VEA_INBOX_ARB_TO_ETH=0x...
VEA_OUTBOX_ARB_TO_ETH=0x...
VEA_INBOX_ARB_TO_GNOSIS=0x...
VEA_OUTBOX_ARB_TO_GNOSIS=0x...
WETH_GNOSIS=0x...
PRIVATE_KEY=0x... (or use test default)
```

## Test Execution

```bash
# Run all tests serially (REQUIRED due to blockchain state)
cargo test -- --test-threads=1

# Run specific test
cargo test test_validator_detects_and_challenges_wrong_claim -- --nocapture

# With output (see println! statements)
cargo test -- --nocapture --test-threads=1
```

## Summary: What You MUST Keep

1. **TestFixture pattern** - snapshot/revert is ESSENTIAL for test isolation
2. **advance_time helper** - required for time-based testing (epochs, delays)
3. **AtomicBool flags** - detect async validator reactions in tests
4. **tokio::spawn + timeout** - test reactive behavior, not just direct function calls
5. **serial_test crate** - prevent tests from interfering with each other

These aren't "nice to have" - they're fundamental to testing a reactive, event-driven validator.
